---
import Layout from '~/layouts/Layout.astro'
import { Button } from '~/components/ui/button'
import LinkButton from '~/components/LinkButton'
import pp from '~/assets/pp.png'
import { getImage, Image } from 'astro:assets'
import pkg from '../../package.json'
import { person, socials, interests, handles } from '~/lib/constants'
import { getEntry } from 'astro:content'

const optimizedPP = await getImage({
  src: pp,
  format: 'avif',
  width: 512,
  quality: 50,
})
const buildId = pkg.version
const magicEntry = await getEntry('sections', 'intro')
const { Content: Intro } = await magicEntry.render()
---

<Layout>
  <main class="mx-auto max-w-4xl px-4 py-24 sm:px-6 lg:px-8" data-build-id={buildId}>
    <div class="text-center">
      <Image
        src={optimizedPP.src}
        width={512}
        height={512}
        loading={'eager'}
        alt={`${person.handle}'s profile picture`}
        class="mx-auto mb-8 size-48 rounded-full grayscale contrast-200 mix-blend-lighten transition-transform duration-300 hover:scale-105"
      />
      <h1
        class="my-8 text-4xl font-bold tracking-tight sm:text-8xl text-transparent bg-gradient-to-b from-primary to-primary/10 bg-clip-text"
      >
        {person.handle}
      </h1>
      <div class="mt-10 flex flex-wrap justify-center gap-4">
        <LinkButton variant="outline" href={socials.github} external>
          <span class="i-ph:github-logo-duotone size-5"></span>
          {handles.github}
        </LinkButton>
        <LinkButton variant="outline" href={socials.twitter} external>
          <span class="i-ph:x-logo-duotone size-5"></span>
          {handles.twitter}
        </LinkButton>
        <Button variant="outline" class="cursor-default hover:bg-transparent">
          <span class="i-ph:discord-logo-duotone size-5"></span>
          {handles.discord}
        </Button>
        <LinkButton variant="outline" href={`mailto:${person.email}`}>
          <span class="i-ph:envelope-duotone size-5"></span>
          {person.email}
        </LinkButton>
      </div>
    </div>

    <div class="mt-24 flex flex-col gap-18 w-fit max-w-xl mx-auto">
      <div class="flex flex-col gap-4">
        <h2 class="text-2xl font-semibold">Interests</h2>
        <p class="text-muted-foreground">{interests.coding}</p>
        <p class="text-muted-foreground">{interests.other}</p>
      </div>
      <div class="flex flex-col gap-4 [&_h2]:text-2xl [&_h2]:font-semibold [&_p]:text-muted-foreground">
        <Intro />
      </div>
      <div class="flex sm:flex-row flex-col gap-1 mx-a text-muted-foreground">
        <span>
          This site is
          <span id="size-compressed" class="text-primary font-bold" title="Estimated uncached compressed size">
            …
          </span>
          compressed…
        </span>
        <span>
          <span id="cached-wrap">
            and
            <span id="size-cached" class="text-primary font-bold" title="Transferred bytes this view"> … </span>
            after caching.
          </span>
        </span>
      </div>
    </div>
  </main>
</Layout>

<script is:inline>
  ;(function () {
    function formatBytes(bytes) {
      if (!bytes || bytes < 1024) return `${bytes | 0}B`
      const kb = bytes / 1024
      if (kb < 1024) return `${kb.toFixed(1)}kB`
      const mb = kb / 1024
      return `${mb.toFixed(2)}MB`
    }

    function isSameOrigin(url) {
      try {
        const u = new URL(url, location.href)
        return u.origin === location.origin && (u.protocol === 'http:' || u.protocol === 'https:')
      } catch {
        return false
      }
    }

    function computeSizes() {
      const navEntries = performance.getEntriesByType('navigation')
      const resourceEntries = performance.getEntriesByType('resource')

      let encoded = 0
      let transferred = 0

      if (navEntries && navEntries.length) {
        const nav = navEntries[0]
        encoded += nav.encodedBodySize || 0
        transferred += nav.transferSize || 0
      }

      for (const e of resourceEntries) {
        if (!isSameOrigin(e.name)) continue
        encoded += e.encodedBodySize || 0
        transferred += e.transferSize || 0
      }
      const compressedEl = document.getElementById('size-compressed')
      const cachedEl = document.getElementById('size-cached')
      const cachedWrap = document.getElementById('cached-wrap')
      const buildId = document.querySelector('main')?.dataset.buildId || 'dev'
      const storageKey = `size:${buildId}`
      try {
        const existing = localStorage.getItem(storageKey)
        const parsed = existing ? JSON.parse(existing) : null
        const isFirstViewOfBuild = !existing
        let baseline = parsed && typeof parsed.encoded === 'number' ? parsed.encoded : 0
        if (encoded > baseline) {
          baseline = encoded
          localStorage.setItem(storageKey, JSON.stringify({ encoded: baseline }))
        }
        if (compressedEl) compressedEl.textContent = formatBytes(baseline || encoded)
        if (isFirstViewOfBuild) {
          if (cachedWrap) cachedWrap.style.display = 'none'
        } else if (cachedEl) {
          cachedEl.textContent = formatBytes(transferred)
        }
      } catch {
        if (compressedEl) compressedEl.textContent = formatBytes(encoded)
        if (cachedEl) cachedEl.textContent = formatBytes(transferred)
      }
    }
    if (document.readyState === 'complete') computeSizes()
    else window.addEventListener('load', computeSizes, { once: true })
  })()
</script>
